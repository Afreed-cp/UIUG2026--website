---
import type { BlockListItem } from '../../lib/blockRenderer';
import { fetchContentById, fetchHomepage, fetchChildren, fetchContentItems, fetchContentByRoute } from '../../lib/umbraco';
import { mapEvent } from '../../lib/umbracoMappers';
import type { UmbracoEvent } from '../../types/umbraco';
import type { Event } from '../../types';
import EventsList from './EventsList';

interface Props {
  block: BlockListItem;
}

const { block } = Astro.props;
const props = block.properties;

// Events should always be provided via props.threads from the Block List configuration
let events: Event[] = [];
if (props.threads && Array.isArray(props.threads)) {
  // Events are provided in the block properties, but properties might be empty
  // Fetch full content for each event by ID to get their properties
  try {
    const eventPromises = (props.threads as any[]).map(async (item) => {
      // If properties are empty, fetch the full content by ID
      if (!item.properties || Object.keys(item.properties).length === 0) {
        try {
          const fullEvent = await fetchContentById(item.id);
          if (fullEvent) {
            return mapEvent(fullEvent as UmbracoEvent);
          }
        } catch (err) {
          console.warn(`[EventsBlock] Could not fetch event ${item.id}:`, err);
        }
      }
      
      // Use existing properties if available
      const eventProps = item.properties || {};
      return {
        id: item.id || '',
        title: eventProps.title || item.name || '',
        category: eventProps.category || '',
        user: eventProps.user || '',
        status: eventProps.status || 'STABLE',
        timestamp: eventProps.timestamp || '',
      };
    });
    
    events = await Promise.all(eventPromises);
  } catch (error) {
    console.error('[EventsBlock] Error processing events from props:', error);
  }
}

// Fetch all events for the archive
// First try to find Events page by route, then fetch its children
// If Events page doesn't exist, fetch events directly from homepage
let allEvents: Event[] = [];
try {
  // First, try to find Events page by route
  let eventsPage = await fetchContentByRoute('/events/');
  
  // If not found by route, try to find it as a child of homepage
  if (!eventsPage || eventsPage.contentType !== 'events') {
    const homepage = await fetchHomepage();
    if (homepage?.id) {
      const homepageChildren = await fetchChildren(homepage.id);
      const foundEventsPage = homepageChildren.find(item => item.contentType === 'events');
      if (foundEventsPage) {
        eventsPage = foundEventsPage;
      }
    }
  }
  
  if (eventsPage && eventsPage.id) {
    // Fetch all Event documents that are children of the Events page
    const allEventItems = await fetchChildren(eventsPage.id, 'event');
    allEvents = (allEventItems as UmbracoEvent[])
      .filter(item => item.contentType === 'event')
      .map(mapEvent);
  }
  
  // If we still don't have events, fetch all events directly
  // This handles cases where Events page doesn't exist or fetchChildren didn't work
  if (allEvents.length === 0) {
    const allEventItems = await fetchContentItems('event');
    allEvents = (allEventItems as UmbracoEvent[])
      .filter(item => item.contentType === 'event')
      .map(mapEvent);
  }
} catch (error) {
  console.error('[EventsBlock] Error fetching all events for archive:', error);
}
---

<EventsList 
  client:load
  events={events}
  allEvents={allEvents}
  title={props.title}
/>

